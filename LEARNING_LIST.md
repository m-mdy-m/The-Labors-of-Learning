### [**Foundational Concepts**](./Foundational/)

#### 1. **Understanding Programming Basics**

- **Syntax and Semantics**
- **Variables and Data Types**
- **Expressions and Operators**
- **Input and Output**

#### 2. **Basic Control Structures**

- **Sequence (Execution Order)**
- **Selection (Conditionals: if-else, switch)**
- **Iteration (Loops: for, while, do-while)**

#### 3. **Introduction to Algorithms**

- **Pseudocode**
- **Flowcharts**
- **Basic Searching (Linear, Binary)**
- **Basic Sorting (Bubble, Insertion, Selection)**

---

### **Imperative Paradigm**

- **Structured Programming**
  - Subroutines and Functions
  - Scope and Lifetime of Variables
  - Pass by Value vs Pass by Reference
- **Procedural Programming**
  - Modularity
  - Procedure Calls
  - State Management

---

### **Object-Oriented Paradigm**

- **Introduction to Objects and Classes**
- **Encapsulation**
- **Abstraction**
- **Inheritance**
- **Polymorphism**
- **Object Composition**
- **SOLID Principles**
  - Single Responsibility Principle
  - Open/Closed Principle
  - Liskov Substitution Principle
  - Interface Segregation Principle
  - Dependency Inversion Principle
- **Design Patterns**
  - Creational Patterns (e.g., Singleton, Factory)
  - Structural Patterns (e.g., Adapter, Composite)
  - Behavioral Patterns (e.g., Observer, Strategy)

---

### **Declarative Paradigm**

- **Introduction to Declarative Programming**
  - Difference from Imperative Programming
- **Functional Programming**
  - Pure Functions
  - Immutability
  - Higher-Order Functions
  - First-Class Functions
  - Recursion
  - Function Composition
  - Lazy Evaluation
  - Referential Transparency
- **Logic Programming**
  - Facts, Rules, and Queries
  - Unification
  - Backtracking
- **Constraint Programming**
  - Constraints as Relations
  - Domain Reduction
  - Propagation
- **Reactive Programming**
  - Observables
  - Streams
  - Data Flow

---

### **Metaprogramming**

- **Reflection**
- **Code Generation**
- **Macros**
- **Annotations**
- **Aspect-Oriented Programming (AOP)**
- **Dynamic Dispatch**

---

### **Concurrent and Parallel Programming**

- **Introduction to Concurrency and Parallelism**
  - Difference Between Concurrent and Parallel
- **Multithreading**
  - Threads and Thread Pools
  - Locks and Synchronization
- **Asynchronous Programming**
  - Async/Await
  - Promises/Futures
- **Parallel Programming**
  - Data Parallelism
  - Task Parallelism
- **Message Passing**
  - Actors Model
  - Channels
- **Lock-Free and Wait-Free Algorithms**
- **Concurrency Control**
  - Deadlock, Livelock, and Starvation
  - Semaphores
  - Monitors

---

### **Event-Driven Programming**

- **Event Loops**
- **Callbacks**
- **Event Emitters/Listeners**
- **Reactive Extensions (Rx)**
- **Publish/Subscribe (Pub/Sub) Pattern**

---

### **Data-Oriented Paradigm**

- **Data-Driven Programming**
- **Data-Oriented Design (DOD)**
- **Entity-Component-System (ECS) Architecture**

---

### **Aspect-Oriented Programming (AOP)**

- **Cross-Cutting Concerns**
- **Aspects**
- **Join Points and Pointcuts**
- **Advice Types (Before, After, Around)**

---

### **Domain-Driven Design (DDD)**

- **Entities and Value Objects**
- **Aggregates and Repositories**
- **Services**
- **Domain Events**
- **Bounded Contexts**
- **Ubiquitous Language**

---

### **Component-Based Software Engineering**

- **Components and Interfaces**
- **Composition**
- **Dependency Injection**
- **Service-Oriented Architecture (SOA)**
- **Microservices**

---

### **Model-Driven Development**

- **Model-Driven Architecture (MDA)**
- **Domain-Specific Languages (DSLs)**
- **Model Transformation**

---

### **Agent-Oriented Programming**

- **Agents**
- **Belief-Desire-Intention (BDI) Model**
- **Multi-Agent Systems**

---

### **Genetic Programming**

- **Evolutionary Algorithms**
- **Mutation, Crossover, Selection**
- **Fitness Functions**

---

### **Quantum Programming (Emerging)**

- **Quantum Bits (Qubits)**
- **Superposition and Entanglement**
- **Quantum Gates**
- **Quantum Algorithms (e.g., Shor's, Grover's)**

### **Additional Paradigms and Techniques**

#### **Aspect-Oriented Programming (AOP)**

- **Cross-Cutting Concerns**
- **Aspects**
- **Join Points and Pointcuts**
- **Advice Types (Before, After, Around)**

#### **Model-Based Testing (MBT)**

- **Model Generation**
- **Test Case Derivation**
- **Model Checking**

#### **Generative Programming**

- **Template Metaprogramming**
- **Code Generation Techniques**
- **Domain-Specific Code Generators**

#### **Flow-Based Programming (FBP)**

- **Components and Black-Box Processes**
- **Information Packets (IPs)**
- **Directed Graphs**
- **Asynchronous Data Flow**

#### **Automata-Based Programming**

- **Finite State Machines (FSM)**
- **State Transition Diagrams**
- **Event-Driven State Machines**

#### **Object-Relational Mapping (ORM)**

- **Mapping Techniques**
- **Entity-Relationship Mapping**
- **Lazy Loading vs. Eager Loading**

#### **Language-Oriented Programming (LOP)**

- **Domain-Specific Languages (DSLs)**
- **Language Workbenches**
- **Syntax and Semantics Customization**

#### **Behavior-Driven Development (BDD)**

- **Given-When-Then Syntax**
- **User Stories**
- **Executable Specifications**

#### **Memory Management Paradigms**

- **Manual Memory Management**
- **Garbage Collection**
- **Reference Counting**
- **Automatic Reference Counting (ARC)**

#### **Service-Oriented Paradigm**

- **Service-Oriented Architecture (SOA)**
- **Microservices**
- **Web Services (SOAP, REST)**

#### **Test-Driven Development (TDD)**

- **Red-Green-Refactor Cycle**
- **Unit Testing**
- **Test Automation Frameworks**

#### **Probabilistic Programming**

- **Probabilistic Models**
- **Bayesian Inference**
- **Monte Carlo Methods**
